<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=contain">
    <meta name="screen-orientation" content="landscape">
    <meta name="x5-orientation" content="landscape">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#ff69b4">
    <title>„Å¥„ÇàÊ∞è„ÅÆÂÜíÈô∫</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
            background: #000000;
            font-family: 'Courier New', monospace;
            user-select: none;
            touch-action: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            position: fixed;
            width: 100%;
        }
        
        @media screen and (orientation: portrait) {
            body::before {
                content: "üîÑüåöÁîªÈù¢„ÇíÊ®™Âêë„Åç„Å´„Åô„Çã„É≥„Ç¥üåù";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(135deg, #ffb6c1, #ffc0cb, #ff69b4);
                color: white;
                font-size: 6vw;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
                text-align: center;
                padding: 20px;
            }
            
            #gameContainer {
                display: none;
            }
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh !important;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 40%, #FFB6C1 70%, #FFC0CB 100%);
            overflow: visible !important;
            display: block;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            object-fit: contain;
        }
        
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            font-size: 3.5vw;
            text-shadow: 2px 2px 4px rgba(255,20,147,0.8);
            font-weight: bold;
            z-index: 100;
            line-height: 1.2;
            display: block !important;
        }
        
        @media (min-width: 600px) {
            #ui {
                font-size: 16px;
            }
        }
        
        #pauseButton {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px;
            font-size: 4vw;
            border-radius: 8px;
            cursor: pointer;
            z-index: 15;
            font-weight: bold;
        }
        
        @media (min-width: 600px) {
            #pauseButton {
                font-size: 18px;
                padding: 10px;
            }
        }
        
        #startScreen, #pauseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            padding: 5px;
            cursor: pointer;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        #startScreen.hidden, #pauseScreen.hidden {
            display: none;
        }
        
        #titleImage {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            object-fit: cover;
            display: block;
        }

        @media (min-width: 600px) {
            #titleImage {
                width: auto;
                height: auto;
                max-width: 60vw;
                max-height: 40vh;
            }
        }
        
        .game-button {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 4vw;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 6px 15px rgba(255,20,147,0.4);
            font-family: 'Courier New', monospace;
            margin: 5px;
            transition: all 0.3s ease;
            min-width: 50vw;
            max-width: 280px;
        }
        
        @media (min-width: 600px) {
            .game-button {
                font-size: 16px;
                padding: 15px 30px;
                min-width: auto;
            }
        }
        
        .game-button:hover {
            background: linear-gradient(135deg, #ff1493, #dc143c);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255,20,147,0.6);
        }
        
        .instruction-text {
            display: none;
        }

        @media (min-width: 600px) {
            .instruction-text {
                display: block;
                color: white;
                font-size: 14px;
                text-align: center;
                margin: 5px 0;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                font-weight: bold;
                padding: 0 10px;
            }
        }
        
        .game-title {
            font-size: 8vw;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            margin-bottom: 15px;
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
            display: block;
            z-index: 1000;
            position: relative;
        }
        
        @media (min-width: 600px) {
            .game-title {
                font-size: 24px;
            }
        }
        
        .touch-area {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(255,182,193,0.2);
            border: 2px dashed rgba(255,255,255,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 4vw;
            text-shadow: 1px 1px 2px rgba(255,20,147,0.8);
            opacity: 0.4;
            transition: opacity 0.3s;
            font-weight: bold;
            z-index: 5;
        }
        
        @media (min-width: 600px) {
            .touch-area {
                font-size: 16px;
            }
        }
        
        .touch-area.left-active .left-area-highlight {
            background: rgba(255, 255, 255, 0.4) !important;
        }
        
        .touch-area.right-active .right-area-highlight {
            background: rgba(255, 100, 100, 0.4) !important;
        }
        
        #leftArea {
            left: 0;
            width: 67%;
            background: rgba(255,182,193,0.2);
            border-right: 1px solid rgba(255, 255, 255, 0.4);
        }
        
        #rightArea {
            right: 0;
            width: 33%;
            background: rgba(255,182,193,0.2);
        }
        
        .version-text {
            color: #ffffff !important;
            font-size: 1.5vw;
            text-align: center;
            margin: 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            font-weight: bold;
            display: inline-block;
            background: rgba(0,0,0,0.3);
            padding: 1px 4px;
            border-radius: 3px;
        }
        
        @media (min-width: 600px) {
            .version-text {
                font-size: 12px;
            }
        }
        
        .last-update {
            color: rgba(255, 255, 255, 0.6);
            font-size: 1vw;
            text-align: center;
            margin-top: 1px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            font-weight: normal;
            opacity: 0.7;
        }
        
        @media (min-width: 600px) {
            .last-update {
                font-size: 9px;
            }
        }

        #rankingScreen, #updateHistoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 9999;
            padding: 10px;
            overflow: hidden;
        }
        
        #rankingScreen.hidden, #updateHistoryScreen.hidden {
            display: none;
        }
        
        @media (max-width: 599px) {
            #startButton {
                display: none;
            }
        }

        .tap-to-start {
            color: white;
            font-size: 5vw;
            text-align: center;
            margin-top: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        @media (min-width: 600px) {
            .tap-to-start {
                font-size: 16px;
            }
        }

        #rankingList, #updateHistoryList {
            scrollbar-width: thin;
            scrollbar-color: #ff69b4 rgba(0,0,0,0.3);
        }

        #rankingList::-webkit-scrollbar, #updateHistoryList::-webkit-scrollbar {
            width: 8px;
        }

        #rankingList::-webkit-scrollbar-track, #updateHistoryList::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        #rankingList::-webkit-scrollbar-thumb, #updateHistoryList::-webkit-scrollbar-thumb {
            background: #ff69b4;
            border-radius: 4px;
        }

        #rankingList::-webkit-scrollbar-thumb:hover, #updateHistoryList::-webkit-scrollbar-thumb:hover {
            background: #ff1493;
        }

        @keyframes gentlePulse {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        .tap-text {
            animation: gentlePulse 3s ease-in-out infinite;
        }

        #titleButtons button {
            z-index: 100 !important;
            pointer-events: auto !important;
            position: relative !important;
        }

        @media (max-width: 599px) {
            #titleButtons {
                right: 8px !important;
                top: 45% !important;
                transform: translateY(-50%) !important;
                gap: 8px !important;
            }
            
            #titleButtons .game-button {
                font-size: 3.2vw !important;
                padding: 6px 10px !important;
                min-width: auto !important;
                max-width: 32vw !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                border-radius: 8px !important;
            }
        }

        @media (max-width: 400px) {
            #titleButtons {
                right: 5px !important;
                top: 40% !important;
                transform: translateY(-50%) !important;
            }
            
            #titleButtons .game-button {
                font-size: 2.8vw !important;
                padding: 5px 8px !important;
                max-width: 28vw !important;
            }
        }

        @media (max-width: 900px) and (orientation: landscape) {
            #titleButtons {
                right: 10px !important;
                top: 50% !important;
            }
            
            #titleButtons .game-button {
                font-size: 2.5vw !important;
                padding: 8px 12px !important;
            }
        }

        @supports (-webkit-touch-callout: none) {
            body {
                padding-left: env(safe-area-inset-left) !important;
                padding-right: env(safe-area-inset-right) !important;
            }
            
            #gameContainer {
                padding-left: 0 !important;
                padding-right: 0 !important;
                margin-left: env(safe-area-inset-left);
                margin-right: env(safe-area-inset-right);
            }
            
            #startScreen {
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
            
            #titleButtons {
                right: calc(8px + env(safe-area-inset-right)) !important;
            }
            
            #startScreen img {
                position: absolute;
                left: 50% !important;
                transform: translateX(-50%) !important;
            }
        }

        @media only screen 
            and (device-width: 393px) 
            and (device-height: 852px) 
            and (-webkit-device-pixel-ratio: 3) {
            
            #titleButtons {
                right: calc(15px + env(safe-area-inset-right)) !important;
                top: 42% !important;
            }
            
            #titleButtons .game-button {
                max-width: 28vw !important;
                font-size: 2.8vw !important;
            }
        }
    </style>
    
    <script src="https://www.gstatic.com/firebasejs/11.8.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.8.1/firebase-database-compat.js"></script>
</head>
<body>
    <div id="gameContainer">
       <canvas id="gameCanvas" width="1000" height="550"></canvas>

        <div id="ui" style="display: block !important; visibility: visible !important; z-index: 1000 !important;">
            <div>üìè <span id="distance">0</span>m</div>
            <div>üí¥ <span id="score">0</span></div>
            <div>üíñ <span id="lives">3</span></div>
            <div>üëπ <span id="enemyKills">0</span>‰ΩìÊíÉÁ†¥</div>
            <div>‚ö° „É¨„Éô„É´<span id="speedLevel">1</span> (<span id="speedPercent">100</span>%)</div>
            <div>üìà Ê¨°„Åæ„Åß<span id="nextSpeedUp">300</span>m</div>
        </div>

        <div id="splashScreen" onclick="startApp()" style="
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100vw; 
            height: 100vh; 
            background: #000000; 
            display: flex; 
            flex-direction: column; 
            justify-content: space-between; 
            align-items: center; 
            z-index: 1000;
            cursor: pointer;
            padding: 5vh 5vw;
        ">
            <div style="color: white; font-size: 3.5vw; text-align: center; font-family: 'Arial', sans-serif; margin-top: 3vh;">
                ‚ö†Ô∏è Ê≥®ÊÑè ‚ö†Ô∏è<br>
                Êú¨‰ΩúÂìÅ„ÅØÂØæË±°Âπ¥ÈΩ¢„Çí2Ê≠≥‰ª•‰∏ä„Å®Ë®≠ÂÆö„Åó„Å¶„Åä„Çä„Åæ„Åô
            </div>
            
            <div style="color: white; font-size: 2.5vw; text-align: center; font-family: 'Arial', sans-serif; line-height: 1.8;">
                Music by Âñú„Å≥„Åä„Åò„Åï„Çì<br>
                Created by Âñú„Å≥„Åä„Åò„Åï„Çì
            </div>
            
            <div class="tap-text" style="color: white; font-size: 8vw; font-weight: bold; text-align: center; font-family: 'Arial', sans-serif;">
                Please Tap
            </div>
            
            <div style="color: white; font-size: 2vw; text-align: center; font-family: 'Arial', sans-serif; margin-bottom: 2vh;">
                ¬©2025 „Å¥„ÇàÊ∞è„ÅÆÂÜíÈô∫
            </div>
        </div>
    
        <div id="startScreen" onclick="handleTitleScreenClick(event)" style="position: relative; width: 100vw; height: 100vh; overflow: hidden;">
            <img src="https://github.com/RhynAkesora/piyo/blob/main/logo.png?raw=true" alt="„É≠„Ç¥" style="position: absolute; top: -3%; left: 50%; transform: translateX(-50%); width: 25vw; height: auto; z-index: 10;">
            
            <img id="titleImage" alt="„Å¥„ÇàÊ∞è„ÅÆÂÜíÈô∫" style="position: absolute; top: 18vh; left: 0; width: 100vw; height: 65vh; object-fit: contain; z-index: 1;">
            
            <div style="position: absolute; bottom: 8vh; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; align-items: center; gap: 8px; color: white; font-size: 1.2vw; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); font-weight: bold; justify-content: center;">
                <span style="background: rgba(0,0,0,0.4); padding: 3px 8px; border-radius: 6px;">Ver.0.952</span>
                <span style="font-size: 1.0vw; opacity: 0.8; font-weight: normal;">LastUpDate 2025/06/08 23:30</span>
            </div>

            <div id="titleButtons" style="position: absolute; top: 50%; right: 15px; transform: translateY(-50%); display: flex; flex-direction: column; gap: 10px; z-index: 25;">
                <button class="game-button" id="updateHistoryButton">üìù Êõ¥Êñ∞Â±•Ê≠¥</button>
                <button class="game-button" id="rankingButton">üèÜ „É©„É≥„Ç≠„É≥„Ç∞</button>
            </div>
   
            <div class="instruction-text" style="font-size: 3vw; margin-top: 10px; opacity: 0.8;">
                <div style="margin-top: 15px; text-align: center;">
                    <div style="position: absolute; bottom: 0.5vh; left: 50%; transform: translateX(-50%); z-index: 10; text-align: center; color: rgba(255, 255, 255, 0.7); font-size: 1.5vw; text-shadow: 1px 1px 2px rgba(0,0,0,0.6); line-height: 1.2;">
                        ¬© 2025 „Å¥„ÇàÊ∞è„ÅÆÂÜíÈô∫<br>
                        Created by Âñú„Å≥„Åä„Åò„Åï„Çì
                    </div>
                </div>
                <div id="startMessage" style="position: absolute; bottom: 3vh; left: 50%; transform: translateX(-50%); z-index: 10; font-size: 2vw; text-align: center; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); font-weight: bold; background: rgba(76, 175, 80, 0.8); padding: 8px 20px; border-radius: 25px;">ÁîªÈù¢„Çí„Çø„ÉÉ„Éó„ÅßÈñãÂßã</div>
            </div>
        </div>
        
        <div id="pauseScreen" class="hidden">
            <div class="game-title">‚è∏Ô∏è „Éù„Éº„Ç∫‰∏≠</div>
            <button id="resumeButton" class="game-button" onclick="pauseGame()">‚ñ∂Ô∏è ÂÜçÈñã</button>
            <button id="restartButton" class="game-button" onclick="resetGame()">üîÑ „É™„Çπ„Çø„Éº„Éà</button>
            <div class="instruction-text">ÁîªÈù¢„Çí„Çø„ÉÉ„Éó„Åæ„Åü„ÅØ„Çπ„Éö„Éº„Çπ„Ç≠„Éº„ÅßÂÜçÈñã</div>
        </div>

        <div id="rankingScreen" class="hidden">
            <div style="color: #ffd700; font-size: 4vw; font-weight: bold; margin-bottom: 8px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">üèÜ „É©„É≥„Ç≠„É≥„Ç∞</div>
            
            <div style="display: flex; gap: 3px; margin-bottom: 8px; flex-wrap: wrap; justify-content: center;">
                <button class="game-button" onclick="showRankingByType('score')" id="scoreRankingBtn" style="font-size: 2vw; padding: 4px 8px; min-width: auto; margin: 2px;">üí¥ ÈáëÈ°ç</button>
                <button class="game-button" onclick="showRankingByType('distance')" id="distanceRankingBtn" style="font-size: 2vw; padding: 4px 8px; min-width: auto; margin: 2px;">üìè Ë∑ùÈõ¢</button>
                <button class="game-button" onclick="showRankingByType('enemyKills')" id="killsRankingBtn" style="font-size: 2vw; padding: 4px 8px; min-width: auto; margin: 2px;">üëπ ÊíÉÁ†¥</button>
                <button class="game-button" onclick="showRankingByType('speedLevel')" id="levelRankingBtn" style="font-size: 2vw; padding: 4px 8px; min-width: auto; margin: 2px;">‚ö° „É¨„Éô„É´</button>
            </div>
            
            <div id="rankingList" style="background: rgba(0,0,0,0.8); border: 2px solid #ff69b4; border-radius: 10px; padding: 8px; width: 95vw; height: 50vh; overflow-y: auto; overflow-x: hidden; color: white; font-size: 2.2vw; -webkit-overflow-scrolling: touch; touch-action: pan-y; overscroll-behavior: contain; position: relative; z-index: 100;">
                <div style="text-align: center; color: white;">üì° Ë™≠„ÅøËæº„Åø‰∏≠...</div>
            </div>
            <button class="game-button" onclick="hideRanking()" style="margin-top: 10px; z-index: 31; font-size: 3vw; padding: 8px 16px;">üîô Êàª„Çã</button>
        </div>

        <div id="updateHistoryScreen" class="hidden">
            <div style="color: #ffd700; font-size: 4vw; font-weight: bold; margin-bottom: 8px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">üìù Êõ¥Êñ∞Â±•Ê≠¥</div>
            
            <div id="updateHistoryList" style="background: rgba(0,0,0,0.8); border: 2px solid #8a2be2; border-radius: 10px; padding: 8px; width: 95vw; height: 65vh; overflow-y: auto; overflow-x: hidden; color: white; font-size: 2.5vw; -webkit-overflow-scrolling: touch; touch-action: pan-y; overscroll-behavior: contain;">
                <div style="color: #ffd700; font-weight: bold; margin-bottom: 15px; text-align: center; font-size: 3vw;">ÊúÄÁµÇÊõ¥Êñ∞Êó•: 2025/06/08 23:30</div>
                
                <div style="color: #ffffff; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #8a2be2; padding-bottom: 5px;">üìù Áõ¥Ëøë„ÅÆÊõ¥Êñ∞ÂÜÖÂÆπ</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ „É©„É≥„Ç≠„É≥„Ç∞ÂÖ•ÂäõÁîªÈù¢„ÅÆz-index‰øÆÊ≠£</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ „Ç≥„Éº„ÉâÂìÅË≥™ÊîπÂñÑÔºà„Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞Êï¥ÁêÜÔºâ</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Âº∑Âåñ</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ Ë°®Á§∫‰ΩçÁΩÆ„ÅÆÂæÆË™øÊï¥</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ „É©„É≥„Ç≠„É≥„Ç∞Áî®BGM„ÇíÂÆüË£Ö</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ „Ç¢„ÇØ„Çª„ÇπÁîªÈù¢„ÇíËøΩÂä†</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ Ê≥®ÊÑèÊõ∏„ÅçÁîªÈù¢„ÇíËøΩÂä†„ÄÅ„Çµ„Ç¶„É≥„Éâ„ÅÆË®≠ÂÆöÂ§âÊõ¥„ÄÅ„Çø„Ç§„Éà„É´ÁîªÂÉèËøΩÂä†</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ BGM„Éï„Ç°„Ç§„É´„ÇíÂÆüË£Ö</div>
                <div style="margin-bottom: 8px; padding-left: 5px;">‚Ä¢ „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÈü≥„ÇíËøΩÂä†</div>
            </div>
            
            <button class="game-button" onclick="hideUpdateHistory()" style="margin-top: 10px; z-index: 31; font-size: 3vw; padding: 8px 16px;">üîô Êàª„Çã</button>
        </div>
        
        <div id="nameInputScreen" class="hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 10000;">
            <div style="color: #ffd700; font-size: 6vw; font-weight: bold; margin-bottom: 20px;">üéâ „Éè„Ç§„Çπ„Ç≥„Ç¢ÔºÅ</div>
            <div style="color: white; font-size: 4vw; margin-bottom: 10px;">„É©„É≥„Ç≠„É≥„Ç∞„Å´Ë®òÈå≤„Åó„Åæ„Åô</div>
            <div id="scoreToSubmit" style="color: white; font-size: 3vw; margin-bottom: 20px;"></div>
            <input type="text" id="playerNameInput" placeholder="„ÅäÂêçÂâç„ÇíÂÖ•Âäõ" maxlength="10" style="padding: 10px; font-size: 4vw; border-radius: 5px; border: none; margin-bottom: 20px; text-align: center;">
            <div>
                <button class="game-button" onclick="submitScore()">üìù ÁôªÈå≤</button>
                <button class="game-button" onclick="skipSubmit()">‚è≠Ô∏è „Çπ„Ç≠„ÉÉ„Éó</button>
            </div>
        </div>
        
        <div id="leftArea" class="touch-area">
            <div class="left-area-highlight" style="position: absolute; left: 0; top: 0; width: 32.84%; height: 100%; background: rgba(255, 255, 255, 0.15); pointer-events: none; z-index: 1;"></div>
            <div class="right-area-highlight" style="position: absolute; left: 32.84%; top: 0; width: 67.16%; height: 100%; background: rgba(255, 100, 100, 0.15); pointer-events: none; z-index: 1;"></div>
            <div style="position: absolute; left: 32.84%; top: 0; bottom: 0; width: 1px; background: rgba(255, 255, 255, 0.6); transform: translateX(-50%); pointer-events: none; z-index: 3;"></div>
            <div style="position: absolute; left: 16.42%; top: 40%; transform: translateX(-50%); color: rgba(255,255,255,0.7); font-size: 3.5vw; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); pointer-events: none; z-index: 4;">Left</div>
            <div style="position: absolute; left: 66%; top: 40%; transform: translateX(-50%); color: rgba(255,100,100,0.8); font-size: 3.5vw; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); pointer-events: none; z-index: 4;">Right</div>
            <div style="position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.6); font-size: 2.5vw; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); pointer-events: none; z-index: 4;">üì± ‰∏ã„Çπ„ÉØ„Ç§„Éó„ÅßÈôç‰∏ã</div>
        </div>
        <div id="rightArea" class="touch-area">‚≠ê „Ç∏„É£„É≥„Éó</div>
        
        <button id="pauseButton" onclick="pauseGame()">‚è∏Ô∏è</button>
    </div>

<script>
        const DEBUG = false; // „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÔºàÊú¨Áï™Áí∞Â¢É„Åß„ÅØfalseÔºâ
        
        function log(...args) {
            if (DEBUG) console.log(...args);
        }
        
        const firebaseConfig = {
            apiKey: "AIzaSyC0k2m0OcKxA_K10j2ZPmR2pMK5MKZgHAY",
            authDomain: "piyo-adventure-ranking.firebaseapp.com",
            databaseURL: "https://piyo-adventure-ranking-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "piyo-adventure-ranking",
            storageBucket: "piyo-adventure-ranking.firebasestorage.app",
            messagingSenderId: "508462208211",
            appId: "1:508462208211:web:7c52eb1044cfba4c33b026"
        };

        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        let finalGameStats = null;
        
        class SoundManager {
            constructor() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    log('üîä SoundManagerÂàùÊúüÂåñÂÆå‰∫Ü');
                } catch (error) {
                    console.error('AudioContextÂàùÊúüÂåñÂ§±Êïó:', error);
                    this.audioContext = null;
                }

                this.titleBGM = new Audio('title.mp3');
                this.stageBGM = new Audio('stage.mp3');
                this.gameoverBGM = new Audio('gameover.mp3');
                this.rankingBGM = new Audio('ranking.mp3');

                this.titleBGM.loop = true;
                this.stageBGM.loop = true;
                this.gameoverBGM.loop = true;
                this.rankingBGM.loop = true;

                this.titleBGM.volume = 0.6;
                this.stageBGM.volume = 0.5;
                this.gameoverBGM.volume = 0.7;
                this.rankingBGM.volume = 0.6;

                this.currentBGM = null;
                
                log('üéµ BGMÂàùÊúüÂåñÂÆå‰∫Ü');
            }

            createBeep(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.audioContext) return;

                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
            
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
            
                    oscillator.frequency.value = frequency;
                    oscillator.type = type;
            
                    gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
            
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                } catch (error) {
                    console.error('ÂäπÊûúÈü≥ÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }

            playJump() {
                if (!this.audioContext) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.25);
                    
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.35, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                } catch (error) {
                    console.error('„Ç∏„É£„É≥„ÉóÈü≥ÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }

            playKill() {
                if (!this.audioContext) return;
                
                try {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.15);
                    
                    osc.type = 'square';
                    
                    gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    
                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 0.2);
                } catch (error) {
                    console.error('ÊíÉÁ†¥Èü≥ÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }

            playItem() {
                if (!this.audioContext) return;
                
                try {
                    this.createItemNote(523, 0, 0.25);
                    this.createItemNote(659, 50, 0.25);
                    this.createItemNote(784, 100, 0.3);
                    
                    setTimeout(() => {
                        this.createItemNote(523, 0, 0.12);
                        this.createItemNote(659, 50, 0.12);
                        this.createItemNote(784, 100, 0.15);
                    }, 150);
                } catch (error) {
                    console.error('„Ç¢„Ç§„ÉÜ„É†Èü≥ÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }

            createItemNote(frequency, delay, volume) {
                if (!this.audioContext) return;
                
                setTimeout(() => {
                    try {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.value = frequency;
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                        
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + 0.4);
                    } catch (error) {
                        console.error('„Ç¢„Ç§„ÉÜ„É†„Éé„Éº„ÉàÂÜçÁîü„Ç®„É©„Éº:', error);
                    }
                }, delay);
            }

            playCoin() {
                if (!this.audioContext) return;
                
                try {
                    const osc1 = this.audioContext.createOscillator();
                    const gain1 = this.audioContext.createGain();
                    osc1.connect(gain1);
                    gain1.connect(this.audioContext.destination);
                    osc1.frequency.value = 2093;
                    osc1.type = 'sine';
                    gain1.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gain1.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.0625);
                    
                    osc1.start(this.audioContext.currentTime);
                    osc1.stop(this.audioContext.currentTime + 0.0625);
                    
                    setTimeout(() => {
                        if (!this.audioContext) return;
                        
                        const osc2 = this.audioContext.createOscillator();
                        const gain2 = this.audioContext.createGain();
                        osc2.connect(gain2);
                        gain2.connect(this.audioContext.destination);
                        osc2.frequency.value = 2637;
                        osc2.type = 'sine';
                        gain2.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gain2.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.25);
                        
                        osc2.start(this.audioContext.currentTime);
                        osc2.stop(this.audioContext.currentTime + 0.25);
                    }, 62.5);
                } catch (error) {
                    console.error('„Ç≥„Ç§„É≥Èü≥ÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }

            playDamage() {
                if (!this.audioContext) return;
                
                try {
                    const noteDuration = 0.125;
                    const now = this.audioContext.currentTime;
                    
                    this.playDissonantNote(311.13, 329.63, now, noteDuration);
                    this.playDissonantNote(293.66, 311.13, now + noteDuration, noteDuration);
                    this.playDissonantNote(277.18, 293.66, now + noteDuration * 2, noteDuration);
                } catch (error) {
                    console.error('„ÉÄ„É°„Éº„Ç∏Èü≥ÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }

            playDissonantNote(freq1, freq2, startTime, duration) {
                if (!this.audioContext) return;
                
                const osc1 = this.audioContext.createOscillator();
                const gain1 = this.audioContext.createGain();
                osc1.connect(gain1);
                gain1.connect(this.audioContext.destination);
                osc1.frequency.value = freq1;
                osc1.type = 'square';
                gain1.gain.setValueAtTime(0.15, startTime);
                gain1.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                
                const osc2 = this.audioContext.createOscillator();
                const gain2 = this.audioContext.createGain();
                osc2.connect(gain2);
                gain2.connect(this.audioContext.destination);
                osc2.frequency.value = freq2;
                osc2.type = 'square';
                gain2.gain.setValueAtTime(0.12, startTime);
                gain2.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                
                osc1.start(startTime);
                osc2.start(startTime);
                osc1.stop(startTime + duration);
                osc2.stop(startTime + duration);
            }

            playLevelUp() {
                if (!this.audioContext) return;

                try {
                    const duration = 1.2;
                    const now = this.audioContext.currentTime;
                    
                    const melody = this.audioContext.createOscillator();
                    const melodyGain = this.audioContext.createGain();
                    melody.connect(melodyGain);
                    melodyGain.connect(this.audioContext.destination);
                    
                    melody.type = 'sine';
                    melody.frequency.setValueAtTime(659.25, now);
                    melody.frequency.exponentialRampToValueAtTime(698.46, now + 0.3);
                    melody.frequency.exponentialRampToValueAtTime(783.99, now + 0.6);
                    melody.frequency.exponentialRampToValueAtTime(880.00, now + duration);
                    
                    const harmony = this.audioContext.createOscillator();
                    const harmonyGain = this.audioContext.createGain();
                    harmony.connect(harmonyGain);
                    harmonyGain.connect(this.audioContext.destination);
                    
                    harmony.type = 'sine';
                    harmony.frequency.setValueAtTime(523.25, now);
                    harmony.frequency.exponentialRampToValueAtTime(587.33, now + 0.3);
                    harmony.frequency.exponentialRampToValueAtTime(659.25, now + 0.6);
                    harmony.frequency.exponentialRampToValueAtTime(698.46, now + duration);
                    
                    const bass = this.audioContext.createOscillator();
                    const bassGain = this.audioContext.createGain();
                    bass.connect(bassGain);
                    bassGain.connect(this.audioContext.destination);
                    
                    bass.type = 'triangle';
                    bass.frequency.setValueAtTime(261.63, now);
                    bass.frequency.exponentialRampToValueAtTime(293.66, now + 0.3);
                    bass.frequency.exponentialRampToValueAtTime(329.63, now + 0.6);
                    bass.frequency.exponentialRampToValueAtTime(349.23, now + duration);
                    
                    const sparkle = this.audioContext.createOscillator();
                    const sparkleGain = this.audioContext.createGain();
                    sparkle.connect(sparkleGain);
                    sparkleGain.connect(this.audioContext.destination);
                    
                    sparkle.type = 'square';
                    sparkle.frequency.setValueAtTime(1318.51, now + 0.2);
                    sparkle.frequency.exponentialRampToValueAtTime(1760.00, now + 0.8);
                    
                    melodyGain.gain.setValueAtTime(0.05, now);
                    melodyGain.gain.exponentialRampToValueAtTime(0.25, now + 0.3);
                    melodyGain.gain.exponentialRampToValueAtTime(0.01, now + duration + 0.2);
                    
                    harmonyGain.gain.setValueAtTime(0.05, now);
                    harmonyGain.gain.exponentialRampToValueAtTime(0.2, now + 0.3);
                    harmonyGain.gain.exponentialRampToValueAtTime(0.01, now + duration + 0.2);
                    
                    bassGain.gain.setValueAtTime(0.05, now);
                    bassGain.gain.exponentialRampToValueAtTime(0.15, now + 0.3);
                    bassGain.gain.exponentialRampToValueAtTime(0.01, now + duration + 0.2);
                    
                    sparkleGain.gain.setValueAtTime(0.0, now + 0.2);
                    sparkleGain.gain.exponentialRampToValueAtTime(0.15, now + 0.5);
                    sparkleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.9);
                    
                    melody.start(now);
                    harmony.start(now);
                    bass.start(now);
                    sparkle.start(now + 0.2);
                    
                    melody.stop(now + duration + 0.2);
                    harmony.stop(now + duration + 0.2);
                    bass.stop(now + duration + 0.2);
                    sparkle.stop(now + 0.9);
                } catch (error) {
                    console.error('„É¨„Éô„É´„Ç¢„ÉÉ„ÉóÈü≥ÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }

            playBGM(bgmType) {
                log('üéµ playBGMÂëº„Å≥Âá∫„Åó:', bgmType);
                try {
                    this.stopAllBGM();
                    
                    let targetBGM = null;
                    
                    switch(bgmType) {
                        case 'title':
                            targetBGM = this.titleBGM;
                            break;
                        case 'stage':
                            targetBGM = this.stageBGM;
                            break;
                        case 'gameover':
                            targetBGM = this.gameoverBGM;
                            break;
                        case 'ranking':
                            targetBGM = this.rankingBGM;
                            break;
                        default:
                            console.error('‰∏çÊòé„Å™BGM„Çø„Ç§„Éó:', bgmType);
                            return;
                    }
                    
                    if (targetBGM) {
                        targetBGM.currentTime = 0;
                        targetBGM.play().then(() => {
                            this.currentBGM = targetBGM;
                            log(`BGMÂÜçÁîüÊàêÂäü: ${bgmType}`);
                        }).catch(error => {
                            console.error(`BGMÂÜçÁîüÂ§±Êïó: ${bgmType}`, error);
                        });
                    }
                } catch (error) {
                    console.error('BGMÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }
            
            stopAllBGM() {
                try {
                    [this.titleBGM, this.stageBGM, this.gameoverBGM, this.rankingBGM].forEach(bgm => {
                        if (bgm) {
                            bgm.pause();
                            bgm.currentTime = 0;
                        }
                    });
                    this.currentBGM = null;
                    log('ÂÖ®BGMÂÅúÊ≠¢');
                } catch (error) {
                    console.error('BGMÂÅúÊ≠¢„Ç®„É©„Éº:', error);
                }
            }
            
            resumeCurrentBGM() {
                try {
                    if (this.currentBGM && this.currentBGM.paused) {
                        this.currentBGM.play().then(() => {
                            log('BGMÂÜçÈñã');
                        }).catch(error => {
                            console.error('BGMÂÜçÈñãÂ§±Êïó', error);
                        });
                    }
                } catch (error) {
                    console.error('BGMÂÜçÈñã„Ç®„É©„Éº:', error);
                }
            }
        }

        let soundManager;
    
        async function submitScore() {
            log('submitScoreÈñ¢Êï∞ÈñãÂßã');
            
            const playerName = document.getElementById('playerNameInput').value.trim();
            log('ÂÖ•Âäõ„Åï„Çå„ÅüÂêçÂâç:', playerName);
            
            if (!playerName) { 
                alert('„ÅäÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ');
                document.getElementById('playerNameInput').focus();
                return; 
            }
            
            if (!finalGameStats) {
                console.error('finalGameStats„ÅåÊú™ÂÆöÁæ©');
                alert('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }
            
            try {
                log('FirebaseÈÄÅ‰ø°ÈñãÂßã');
                await database.ref('scores').push({
                    name: playerName,
                    score: finalGameStats.score,
                    distance: finalGameStats.distance,
                    enemyKills: finalGameStats.enemyKills,
                    speedLevel: finalGameStats.speedLevel,
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString('ja-JP')
                });
                
                log('FirebaseÈÄÅ‰ø°ÂÆå‰∫Ü');
                alert(`üéâ „É©„É≥„Ç≠„É≥„Ç∞„Å´ÁôªÈå≤„Åó„Åæ„Åó„ÅüÔºÅ\n${playerName}„Åï„Çì„ÄÅ„ÅäÁñ≤„ÇåÊßò„Åß„Åó„ÅüÔºÅ`);
                hideNameInput();
                showRanking();
            } catch (error) {
                console.error('„Çπ„Ç≥„Ç¢ÈÄÅ‰ø°„Ç®„É©„Éº:', error);
                alert('„Çπ„Ç≥„Ç¢„ÅÆÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ');
            }
        }

        function skipSubmit() {
            log('„Çπ„Ç≠„ÉÉ„ÉóÂÆüË°å');
            hideNameInput();
            resetGame();
        }

        let currentRankingType = 'score';

        async function showRanking() {
            log('„É©„É≥„Ç≠„É≥„Ç∞ÁîªÈù¢Ë°®Á§∫ÈñãÂßã');

            if (soundManager) {
                soundManager.playBGM('ranking');
            }

            const rankingScreen = document.getElementById('rankingScreen');
            
            document.body.appendChild(rankingScreen);
            
            rankingScreen.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: rgba(0,0,0,0.9) !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: flex-start !important;
                align-items: center !important;
                z-index: 9999 !important;
                padding: 10px !important;
                overflow: hidden !important;
            `;
            
            rankingScreen.classList.remove('hidden');

            showRankingByType('score');

            setTimeout(() => {
                const rankingList = document.getElementById('rankingList');
                if (rankingList) {
                    ['touchstart', 'touchmove', 'touchend'].forEach(event => {
                        rankingList.addEventListener(event, (e) => e.stopPropagation());
                    });
                }
            }, 100);
        }
        
        async function showRankingByType(type) {
            log(`${type}„É©„É≥„Ç≠„É≥„Ç∞Ë°®Á§∫ÈñãÂßã`);
            currentRankingType = type;
    
            updateRankingButtons(type);
    
            const rankingList = document.getElementById('rankingList');
            rankingList.innerHTML = '<div style="text-align: center; color: white;">üì° Ë™≠„ÅøËæº„Åø‰∏≠...</div>';
    
            try {
                if (typeof firebase === 'undefined') {
                    throw new Error('FirebaseÊú™ÂàùÊúüÂåñ');
                }
                
                const snapshot = await database.ref('scores').orderByChild(type).limitToLast(20).once('value');
                const data = snapshot.val();
                
                log('ÂèñÂæó„Éá„Éº„Çø:', data);
                
                if (!data) {
                    rankingList.innerHTML = '<div style="text-align: center; color: white;">üìä „Åæ„Å†„É©„É≥„Ç≠„É≥„Ç∞„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                    return;
                }
                
                const rankings = Object.values(data).sort((a, b) => b[type] - a[type]);
                
                const titles = {
                    score: 'üí¥ ÈáëÈ°ç„É©„É≥„Ç≠„É≥„Ç∞',
                    distance: 'üìè Ë∑ùÈõ¢„É©„É≥„Ç≠„É≥„Ç∞',
                    enemyKills: 'üëπ ÊíÉÁ†¥Êï∞„É©„É≥„Ç≠„É≥„Ç∞',
                    speedLevel: '‚ö° „É¨„Éô„É´„É©„É≥„Ç≠„É≥„Ç∞'
                };
                
                const units = {
                    score: 'ÂÜÜ',
                    distance: 'm',
                    enemyKills: '‰Ωì',
                    speedLevel: '„É¨„Éô„É´'
                };
                
                let html = `<div style="text-align: center; color: #ffd700; font-weight: bold; margin-bottom: 8px; font-size: 2.8vw;">${titles[type]}</div>`;
                
                rankings.forEach((entry, index) => {
                    const rank = index + 1;
                    const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üèÖ';
                    
                    html += `<div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.3); color: white; font-size: 2vw;">
                                <span style="color: ${rank <= 3 ? '#ffd700' : 'white'};">${medal}${rank}. ${entry.name}</span>
                                <span style="color: #ffd700; font-weight: bold;">${entry[type]}${units[type]}</span>
                             </div>`;
                });
                
                rankingList.innerHTML = html;
                log('„É©„É≥„Ç≠„É≥„Ç∞Ë°®Á§∫ÂÆå‰∫Ü');
                
            } catch (error) {
                console.error('„É©„É≥„Ç≠„É≥„Ç∞Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
                rankingList.innerHTML = '<div style="text-align: center; color: white;">‚ùå Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü<br>„Ç®„É©„Éº: ' + error.message + '</div>';
            }
        }

        function updateRankingButtons(activeType) {
            const buttons = ['scoreRankingBtn', 'distanceRankingBtn', 'killsRankingBtn', 'levelRankingBtn'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.style.background = 'linear-gradient(135deg, #ff69b4, #ff1493)';
                    btn.style.opacity = '0.7';
                }
            });
    
            const activeButtonIds = {
                score: 'scoreRankingBtn',
                distance: 'distanceRankingBtn',
                enemyKills: 'killsRankingBtn',
                speedLevel: 'levelRankingBtn'
            };
    
            const activeBtn = document.getElementById(activeButtonIds[activeType]);
            if (activeBtn) {
                activeBtn.style.background = 'linear-gradient(135deg, #ff1493, #dc143c)';
                activeBtn.style.opacity = '1';
            }
        }

        function hideRanking() {
            log('„É©„É≥„Ç≠„É≥„Ç∞ÁîªÈù¢„ÇíÈùûË°®Á§∫');
            
            if (soundManager) {
                soundManager.playBGM('title');
            }
            
            const rankingScreen = document.getElementById('rankingScreen');
            rankingScreen.classList.add('hidden');
            rankingScreen.style.display = 'none';
        }

        function showUpdateHistory() {
            log('Êõ¥Êñ∞Â±•Ê≠¥ÁîªÈù¢Ë°®Á§∫');
            
            const updateHistoryScreen = document.getElementById('updateHistoryScreen');
            
            document.body.appendChild(updateHistoryScreen);
            
            updateHistoryScreen.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: rgba(0,0,0,0.9) !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: flex-start !important;
                align-items: center !important;
                z-index: 9999 !important;
                padding: 10px !important;
                overflow: hidden !important;
            `;
            
            updateHistoryScreen.classList.remove('hidden');
            
            setTimeout(() => {
                const updateHistoryList = document.getElementById('updateHistoryList');
                if (updateHistoryList) {
                    ['touchstart', 'touchmove', 'touchend'].forEach(event => {
                        updateHistoryList.addEventListener(event, (e) => e.stopPropagation());
                    });
                }
            }, 100);
        }

        function hideUpdateHistory() {
            log('Êõ¥Êñ∞Â±•Ê≠¥ÁîªÈù¢„ÇíÈùûË°®Á§∫');
            
            const updateHistoryScreen = document.getElementById('updateHistoryScreen');
            updateHistoryScreen.classList.add('hidden');
            updateHistoryScreen.style.display = 'none';
        }

        function showSplashScreen() {
            document.getElementById('splashScreen').style.display = 'flex';
            document.getElementById('startScreen').classList.add('hidden');
        }

        function startApp() {
            log('PWAÈü≥Â£∞ÂàùÊúüÂåñÈñãÂßã');
            
            try {
                soundManager = new SoundManager();
                log('SoundManagerÂàùÊúüÂåñÊàêÂäü');
            } catch (error) {
                console.error('SoundManagerÂàùÊúüÂåñÂ§±Êïó:', error);
                soundManager = null;
            }
            
            document.getElementById('splashScreen').style.display = 'none';
            document.getElementById('startScreen').classList.remove('hidden');
            
            if (soundManager && soundManager.playBGM) {
                try {
                    soundManager.playBGM('title');
                    log('„Çø„Ç§„Éà„É´BGMÂÜçÁîüÈñãÂßã');
                } catch (error) {
                    console.error('„Çø„Ç§„Éà„É´BGMÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }
        }

        function handleTitleScreenClick(event) {
            log('„Çø„Ç§„Éà„É´ÁîªÈù¢„Çø„ÉÉ„ÉóÊ§úÂá∫:', event.target.id);

            if (event.target.id === 'rankingButton') {
                showRanking();
                return;
            }

            if (event.target.id === 'updateHistoryButton') {
                showUpdateHistory();
                return;
            }

            if (event.target.classList.contains('game-button')) {
                return;
            }
            
            startGame();
        }
        
        function showNameInput() {
            log('showNameInputÈñ¢Êï∞ÈñãÂßã');
            
            gameState.gameStarted = false;
            gameState.gamePaused = true;
            
            const nameInputScreen = document.getElementById('nameInputScreen');
            if (nameInputScreen) {
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('rankingScreen').classList.add('hidden');
                
                nameInputScreen.classList.remove('hidden');
                nameInputScreen.style.display = 'flex';
                nameInputScreen.style.zIndex = '10000';
                
                if (finalGameStats) {
                    document.getElementById('scoreToSubmit').textContent = 
                        `Áï•Â•™ÈáëÈ°ç: ${finalGameStats.score}ÂÜÜ | Ë∑ùÈõ¢: ${finalGameStats.distance}m`;
                }
                
                const nameInput = document.getElementById('playerNameInput');
                nameInput.value = '';
                
                setTimeout(() => {
                    nameInput.focus();
                }, 300);
                
                log('ÂêçÂâçÂÖ•ÂäõÁîªÈù¢Ë°®Á§∫ÂÆå‰∫Ü');
            } else {
                console.error('ÂêçÂâçÂÖ•ÂäõÁîªÈù¢Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            }
        }

        function hideNameInput() {
            log('hideNameInputÈñ¢Êï∞ÈñãÂßã');
            showStartScreen();
        }

        async function checkHighScore(gameStats) {
            try {
                const categories = ['score', 'distance', 'enemyKills', 'speedLevel'];

                for (let category of categories) {
                    const snapshot = await database.ref('scores').once('value');
                    const data = snapshot.val();
            
                    if (!data) return true;
            
                    const allRankings = Object.values(data).sort((a, b) => b[category] - a[category]);
                    const top20 = allRankings.slice(0, 20);
                    
                    if (top20.length < 20 || gameStats[category] > top20[top20.length - 1][category]) {
                        return true;
                    }
                }

                return false;
            } catch (error) {
                console.error('„Éè„Ç§„Çπ„Ç≥„Ç¢„ÉÅ„Çß„ÉÉ„ÇØ„Ç®„É©„Éº:', error);
                return true;
            }
        }
        
        log('„Çπ„ÇØ„É™„Éó„ÉàÈñãÂßã');
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        if (!canvas || !ctx) {
            console.error('CanvasË¶ÅÁ¥†„Åæ„Åü„ÅØ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÂèñÂæó„Å´Â§±Êïó');
        }
        
        ctx.imageSmoothingEnabled = false;
        
        const GAME_WIDTH = 1000;
        const GAME_HEIGHT = 550;
        const GRAVITY = 0.7;
        const JUMP_FORCE = -16;
        const MOVE_SPEED = 6;
        const BASE_AUTO_SCROLL_SPEED = 1.2;
        const INVINCIBLE_TIME = 180;
        
        let gameState = {
            score: 0,
            lives: 3,
            camera: { x: 0, y: 0 },
            input: { left: false, right: false, jump: false, jumpPressed: false, down: false },
            recentlyDropped: false,
            dropFromY: 0,
            time: 0,
            gameStarted: false,
            gamePaused: false,
            enemySpawnTimer: 0,
            platformSpawnTimer: 0,
            coinSpawnTimer: 0,
            flyingEnemySpawnTimer: 0,
            powerUpSpawnTimer: 0,
            distance: 0,
            gameSpeed: BASE_AUTO_SCROLL_SPEED,
            lastTerrainX: 0,
            powerUpActive: false,
            powerUpTimer: 0,
            powerUpType: null,
            invincibleTimer: 0,
            isInvincible: false,
            speedLevel: 1,
            lastSpeedUpDistance: 0,
            speedUpNotification: false,
            speedUpNotificationTimer: 0,
            downSwipeTimer: 0,
            downSwipeActive: false,
            isRespawning: false,
            enemyKills: 0
        };
        
        let player = {
            x: 150,
            y: 350,
            width: 48,
            height: 48,
            velX: 0,
            velY: 0,
            onGround: false,
            facing: 'right',
            animFrame: 0
        };
        
        let coins = [];
        let enemies = [];
        let platforms = [];
        let terrain = [];
        let flyingEnemies = [];
        let powerUps = [];
        
        function updateGameSpeed() {
            const currentLevel = Math.floor(gameState.distance / 300) + 1;
            
            if (currentLevel > gameState.speedLevel) {
                gameState.speedLevel = currentLevel;
                gameState.speedUpNotification = true;
                gameState.speedUpNotificationTimer = 120;
                const displayPercent = Math.min(500, 100 + (currentLevel - 1) * 20);
                log(`„É¨„Éô„É´ ${currentLevel} „Çπ„Éî„Éº„Éâ„Ç¢„ÉÉ„Éó (${displayPercent}%)`);
                soundManager.playLevelUp();
            }
            
            const speedMultiplier = 1 + (currentLevel - 1) * 0.20;
            gameState.gameSpeed = BASE_AUTO_SCROLL_SPEED * speedMultiplier;
            
            if (gameState.gameSpeed > BASE_AUTO_SCROLL_SPEED * 5.0) {
                gameState.gameSpeed = BASE_AUTO_SCROLL_SPEED * 5.0;
            }
        }
        
        function gameLoop() {
            if (gameState.gameStarted && !gameState.gamePaused) {
                updateGameSpeed();
                updatePlayer();
                updateEnemies();
                updateCoins();
                updatePowerUps();
                manageTerrain();
                manageObjects();
            }
            
            render();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        function updateUI() {
            document.getElementById('distance').textContent = gameState.distance;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('enemyKills').textContent = gameState.enemyKills;
            
            const speedPercent = Math.min(500, Math.round((100 + (gameState.speedLevel - 1) * 20)));
            const nextSpeedDistance = (gameState.speedLevel * 300) - gameState.distance;
            
            document.getElementById('speedLevel').textContent = gameState.speedLevel;
            document.getElementById('speedPercent').textContent = speedPercent;
            document.getElementById('nextSpeedUp').textContent = Math.max(0, nextSpeedDistance);
        }
        
        function initTerrain() {
            terrain = [];
            for (let x = 0; x < 2000; x += 100) {
                terrain.push({
                    x: x,
                    y: 420,
                    width: 100,
                    height: 130,
                    type: 'ground'
                });
            }
            gameState.lastTerrainX = 1900;
        }
        
        function generateTerrain() {
            const lastTerrain = terrain[terrain.length - 1];
            if (!lastTerrain) return;
            
            const nextX = gameState.lastTerrainX + 100;
            const terrainType = Math.random();
            
            if (terrainType < 0.7) {
                terrain.push({
                    x: nextX,
                    y: 420,
                    width: 100,
                    height: 130,
                    type: 'ground'
                });
            } else if (terrainType < 0.85) {
                const holeWidth = 120 + Math.random() * 100;
                terrain.push({
                    x: nextX,
                    y: 420,
                    width: 0,
                    height: 0,
                    type: 'hole'
                });
                
                terrain.push({
                    x: nextX + holeWidth,
                    y: 420,
                    width: 100,
                    height: 130,
                    type: 'ground'
                });
                gameState.lastTerrainX = nextX + holeWidth;
                return;
            } else {
                const elevation = 60 + Math.random() * 40;
                terrain.push({
                    x: nextX,
                    y: 420 - elevation,
                    width: 100,
                    height: 130 + elevation,
                    type: 'elevated'
                });
            }
            
            gameState.lastTerrainX = nextX;
        }
        
        function manageTerrain() {
            terrain = terrain.filter(t => t.x + t.width > gameState.camera.x - 200);
            
            while (gameState.lastTerrainX < gameState.camera.x + GAME_WIDTH + 500) {
                generateTerrain();
            }
        }
        
        function spawnRandomPlatform() {
            const platformTypes = ['cloud', 'cloud', 'floating_ground'];
            const type = platformTypes[Math.floor(Math.random() * platformTypes.length)];
            
            return {
                x: gameState.camera.x + GAME_WIDTH + Math.random() * 200,
                y: 200 + Math.random() * 150,
                width: 120 + Math.random() * 80,
                height: 30,
                type: type
            };
        }
        
        function spawnRandomCoin() {
            return {
                x: gameState.camera.x + GAME_WIDTH + Math.random() * 300,
                y: 180 + Math.random() * 200,
                width: 32,
                height: 32,
                collected: false,
                animFrame: Math.random() * 20
            };
        }
        
        function spawnRandomEnemy() {
            const enemyTypes = ['chick', 'chick', 'golden_chick', 'mama_chick'];
            const randomType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            
            let width, height, speed;
            switch(randomType) {
                case 'golden_chick':
                    width = 46;
                    height = 42;
                    speed = 1 + Math.random() * 1.5;
                    break;
                case 'mama_chick':
                    width = 50;
                    height = 46;
                    speed = 0.5 + Math.random() * 1;
                    break;
                default:
                    width = 42;
                    height = 38;
                    speed = 1 + Math.random() * 1;
            }
            
            return {
                x: gameState.camera.x + GAME_WIDTH + Math.random() * 200,
                y: 380,
                width: width,
                height: height,
                velX: -speed,
                type: randomType,
                animFrame: Math.floor(Math.random() * 100)
            };
        }
        
        function spawnFlyingEnemy() {
            return {
                x: gameState.camera.x + GAME_WIDTH + Math.random() * 300,
                y: 100 + Math.random() * 200,
                width: 44,
                height: 40,
                velX: -(2 + Math.random() * 2),
                velY: Math.sin(Math.random() * Math.PI * 2) * 0.5,
                type: 'flying_chick',
                animFrame: Math.floor(Math.random() * 100),
                waveOffset: Math.random() * Math.PI * 2
            };
        }
        
        function spawnPowerUp() {
            const random = Math.random() * 1.3158;
            
            let type;
            if (random < 1.0) {
                type = 'lemon_can';
            } else if (random < 1.25) {
                type = 'shield';
            } else {
                type = 'heart';
            }
            
            return {
                x: gameState.camera.x + GAME_WIDTH + Math.random() * 200,
                y: 250 + Math.random() * 100,
                width: 36,
                height: 36,
                type: type,
                collected: false,
                animFrame: 0,
                floatOffset: Math.random() * Math.PI * 2
            };
        }
        
        function manageObjects() {
            const leftBound = gameState.camera.x - 200;
            const rightBound = gameState.camera.x + GAME_WIDTH + 200;
            
            enemies = enemies.filter(e => e.x > leftBound && e.x < rightBound);
            flyingEnemies = flyingEnemies.filter(e => e.x > leftBound && e.x < rightBound);
            platforms = platforms.filter(p => p.x + p.width > leftBound && p.x < rightBound);
            coins = coins.filter(c => c.x > leftBound && c.x < rightBound);
            powerUps = powerUps.filter(p => p.x > leftBound && p.x < rightBound);
            
            gameState.enemySpawnTimer++;
            gameState.platformSpawnTimer++;
            gameState.coinSpawnTimer++;
            gameState.flyingEnemySpawnTimer++;
            gameState.powerUpSpawnTimer++;
            
            if (gameState.enemySpawnTimer > 90 && Math.random() < 0.4) {
                enemies.push(spawnRandomEnemy());
                gameState.enemySpawnTimer = 0;
            }
            
            if (gameState.flyingEnemySpawnTimer > 180 && Math.random() < 0.15) {
                flyingEnemies.push(spawnFlyingEnemy());
                gameState.flyingEnemySpawnTimer = 0;
            }
            
            if (gameState.platformSpawnTimer > 120 && Math.random() < 0.6) {
                platforms.push(spawnRandomPlatform());
                gameState.platformSpawnTimer = 0;
            }
            
            if (gameState.coinSpawnTimer > 60 && Math.random() < 0.5) {
                coins.push(spawnRandomCoin());
                gameState.coinSpawnTimer = 0;
            }
            
            if (gameState.powerUpSpawnTimer > 300 && Math.random() < 0.1) {
                powerUps.push(spawnPowerUp());
                gameState.powerUpSpawnTimer = 0;
            }
        }
        
        function drawPlayer(x, y) {
            ctx.save();
            
            if (gameState.isInvincible) {
                const blinkSpeed = Math.floor(gameState.invincibleTimer / 6) % 2;
                if (blinkSpeed === 0) {
                    ctx.globalAlpha = 0.3;
                }
            }
            
            if (gameState.powerUpType === 'shield') {
                const blinkSpeed = Math.floor(gameState.time / 8) % 2;
                if (blinkSpeed === 1) {
                    ctx.fillStyle = 'rgba(65, 105, 225, 0.6)';
                    ctx.fillRect(x - 8, y - 8, player.width + 16, player.height + 16);
                }
                ctx.fillStyle = 'rgba(30, 144, 255, 0.4)';
                ctx.fillRect(x - 4, y - 4, player.width + 8, player.height + 8);
            }
            
            if (gameState.powerUpType === 'lemon_can') {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.fillRect(x - 4, y - 4, player.width + 8, player.height + 8);
            }
            
            if (player.facing === 'left') {
                ctx.scale(-1, 1);
                x = -x - player.width;
            }
            
            const walkFrame = Math.floor(player.animFrame / 8) % 4;
            const isWalking = Math.abs(player.velX) > 0.5 || gameState.gameSpeed > 0;
            
            ctx.fillStyle = '#f5f5dc';
            ctx.fillRect(x + 6, y + 2, 8, 12);
            ctx.fillRect(x + 34, y + 2, 8, 12);
            
            ctx.fillStyle = '#ffb6c1';
            ctx.fillRect(x + 8, y + 4, 4, 8);
            ctx.fillRect(x + 36, y + 4, 4, 8);
            
            ctx.fillStyle = '#8b4513';
            const leftOffset = isWalking ? Math.sin(walkFrame) * 2 : 0;
            ctx.fillRect(x + 2 + leftOffset, y + 8, 10, 22);
            ctx.fillRect(x + leftOffset, y + 12, 14, 18);
            
            const rightOffset = isWalking ? Math.sin(walkFrame + Math.PI) * 2 : 0;
            ctx.fillRect(x + 36 + rightOffset, y + 8, 10, 22);
            ctx.fillRect(x + 34 + rightOffset, y + 12, 14, 18);
            
            ctx.fillRect(x + 8, y + 4, 32, 16);
            ctx.fillRect(x + 6, y + 8, 36, 14);
            
            ctx.fillStyle = '#fffacd';
            ctx.fillRect(x + 8, y + 1, 32, 4);
            
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(x + 18, y + 2, 12, 8);
            
            ctx.fillStyle = '#ffdbac';
            ctx.fillRect(x + 12, y + 18, 24, 18);
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(x + 16, y + 22, 5, 5);
            ctx.fillRect(x + 26, y + 24, 6, 1);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(x + 17, y + 23, 2, 2);
            
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(x + 20, y + 32, 6, 2);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(x + 8, y + 34, 32, 12);
            
            ctx.fillStyle = '#ff1493';
            ctx.fillRect(x + 16, y + 36, 16, 8);
            
            ctx.fillStyle = '#191970';
            ctx.fillRect(x + 6, y + 44, 36, 4);
            
            ctx.fillStyle = '#ffdbac';
            const armOffset = isWalking ? Math.sin(walkFrame * 2) * 1 : 0;
            ctx.fillRect(x + 2, y + 36 + armOffset, 8, 10);
            ctx.fillRect(x + 38, y + 36 - armOffset, 8, 10);
            
            player.animFrame++;
            ctx.restore();
        }
        
        function drawTerrain(terrain) {
            if (terrain.type === 'hole') return;
            
            let baseColor = terrain.type === 'elevated' ? '#228B22' : '#90ee90';
            ctx.fillStyle = baseColor;
            ctx.fillRect(terrain.x, terrain.y, terrain.width, terrain.height);
            
            ctx.fillStyle = '#32cd32';
            for (let i = 0; i < terrain.width; i += 20) {
                ctx.fillRect(terrain.x + i, terrain.y, 3, 8);
                ctx.fillRect(terrain.x + i + 5, terrain.y, 2, 6);
                ctx.fillRect(terrain.x + i + 10, terrain.y, 3, 7);
            }
        }
        
        function drawPlatform(platform) {
            let baseColor = platform.type === 'cloud' ? '#ffffff' : '#deb887';
            ctx.fillStyle = baseColor;
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            
            if (platform.type === 'cloud') {
                ctx.fillStyle = '#f0f8ff';
                for (let i = 0; i < platform.width; i += 25) {
                    ctx.fillRect(platform.x + i, platform.y + 8, 18, 12);
                }
            }
        }
        
        function drawCoin(coin, time) {
            if (coin.collected) return;
            
            const sparkleFrame = Math.floor(time / 4) % 16;
            const scale = 0.8 + Math.sin(sparkleFrame * Math.PI / 8) * 0.2;
            
            const centerX = coin.x + coin.width / 2;
            const centerY = coin.y + coin.height / 2;
            const size = coin.width * scale;
            
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(centerX - size/4, centerY - size/2, size/2, size);
            ctx.fillRect(centerX - size/2, centerY - size/4, size, size/2);
            
            if (sparkleFrame % 6 < 3) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(centerX - 3, centerY - 8, 6, 3);
                ctx.fillRect(centerX - 3, centerY + 5, 6, 3);
                ctx.fillRect(centerX - 8, centerY - 3, 3, 6);
                ctx.fillRect(centerX + 5, centerY - 3, 3, 6);
            }
        }
        
        function drawEnemy(enemy) {
            let bodyColor, accentColor;
            const bounce = Math.sin(enemy.animFrame / 3) * 1;
            
            switch(enemy.type) {
                case 'golden_chick':
                    bodyColor = '#ffd700';
                    accentColor = '#ffed4e';
                    break;
                case 'mama_chick':
                    bodyColor = '#fff8dc';
                    accentColor = '#f0e68c';
                    break;
                default:
                    bodyColor = '#ffff00';
                    accentColor = '#ffff99';
            }
    
            const currentY = enemy.y + bounce;
            
            ctx.fillStyle = bodyColor;
            ctx.fillRect(enemy.x + 6, currentY + 12, enemy.width - 12, enemy.height - 18);
            ctx.fillRect(enemy.x + 4, currentY + 8, enemy.width - 8, enemy.height - 14);
            ctx.fillRect(enemy.x + 8, currentY + 4, enemy.width - 16, 12);
            
            ctx.fillStyle = accentColor;
            ctx.fillRect(enemy.x + 8, currentY + 10, enemy.width - 16, enemy.height - 20);
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(enemy.x + 12, currentY + 8, 4, 4);
            ctx.fillRect(enemy.x + enemy.width - 16, currentY + 8, 4, 4);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(enemy.x + 13, currentY + 9, 2, 2);
            ctx.fillRect(enemy.x + enemy.width - 15, currentY + 9, 2, 2);
            
            ctx.fillStyle = '#ffa500';
            ctx.fillRect(enemy.x + enemy.width/2 - 2, currentY + 14, 4, 2);
            
            enemy.animFrame++;
        }
            
        function drawFlyingEnemy(enemy) {
            enemy.y += Math.sin(gameState.time * 0.05 + enemy.waveOffset) * 0.8;
            
            const bodyColor = '#ffffff';
            const accentColor = '#ffcccc';
            const combColor = '#ff0000';
            const bounce = Math.sin(enemy.animFrame / 2) * 0.5;
            const currentY = enemy.y + bounce;
            
            ctx.fillStyle = '#f5f5f5';
            const wingFlap = Math.sin(enemy.animFrame / 3) * 8;
            ctx.fillRect(enemy.x - 8, currentY + 8 + wingFlap, 12, 6);
            ctx.fillRect(enemy.x + enemy.width - 4, currentY + 8 - wingFlap, 12, 6);
            
            ctx.fillStyle = bodyColor;
            ctx.fillRect(enemy.x + 6, currentY + 12, enemy.width - 12, enemy.height - 18);
            ctx.fillRect(enemy.x + 4, currentY + 8, enemy.width - 8, enemy.height - 14);
            ctx.fillRect(enemy.x + 8, currentY + 4, enemy.width - 16, 12);
            
            ctx.fillStyle = accentColor;
            ctx.fillRect(enemy.x + 8, currentY + 10, enemy.width - 16, enemy.height - 20);
            
            ctx.fillStyle = combColor;
            ctx.fillRect(enemy.x + enemy.width/2 - 4, currentY + 2, 8, 6);
            ctx.fillRect(enemy.x + enemy.width/2 - 2, currentY, 4, 4);
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(enemy.x + 12, currentY + 8, 4, 4);
            ctx.fillRect(enemy.x + enemy.width - 16, currentY + 8, 4, 4);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(enemy.x + 13, currentY + 9, 2, 2);
            ctx.fillRect(enemy.x + enemy.width - 15, currentY + 9, 2, 2);
            
            ctx.fillStyle = '#ffa500';
            ctx.fillRect(enemy.x + enemy.width/2 - 2, currentY + 14, 4, 2);
            
            enemy.animFrame++;
        }
        
        function drawPowerUp(powerUp) {
            if (powerUp.collected) return;
            
            const floatY = powerUp.y + Math.sin(gameState.time * 0.1 + powerUp.floatOffset) * 3;
            const sparkle = Math.sin(gameState.time * 0.2) * 0.5 + 0.5;
            
            let baseColor, accentColor, emoji;
            switch(powerUp.type) {
                case 'lemon_can':
                    baseColor = '#ffff00';
                    accentColor = '#ffd700';
                    emoji = 'üçã';
                    break;
                case 'shield':
                    baseColor = '#4169e1';
                    accentColor = '#1e90ff';
                    emoji = 'üõ°Ô∏è';
                    break;
                case 'heart':
                    baseColor = '#ff1493';
                    accentColor = '#ff69b4';
                    emoji = '‚ù§Ô∏è';
                    break;
                default:
                    baseColor = '#888888';
                    accentColor = '#aaaaaa';
                    emoji = '?';
            }
            
            ctx.fillStyle = baseColor;
            ctx.fillRect(powerUp.x + 4, floatY + 4, powerUp.width - 8, powerUp.height - 8);
            
            ctx.fillStyle = accentColor;
            ctx.fillRect(powerUp.x + 8, floatY + 8, powerUp.width - 16, powerUp.height - 16);
            
            ctx.fillStyle = `rgba(255, 255, 255, ${sparkle})`;
            ctx.fillRect(powerUp.x + 6, floatY + 6, powerUp.width - 12, powerUp.height - 12);
            
            ctx.fillStyle = '#000000';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(emoji, powerUp.x + powerUp.width/2, floatY + powerUp.height/2 + 6);
            
            powerUp.animFrame++;
        }
        
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        function updatePlayer() {
            if (gameState.downSwipeActive) {
                gameState.downSwipeTimer--;
                if (gameState.downSwipeTimer <= 0) {
                    gameState.downSwipeActive = false;
                    gameState.input.down = false;
                }
            }
            
            if (gameState.isInvincible) {
                gameState.invincibleTimer--;
                if (gameState.invincibleTimer <= 0) {
                    gameState.isInvincible = false;
                }
            }
            
            if (gameState.recentlyDropped) {
                if (player.y > gameState.dropFromY + 60) {
                    gameState.recentlyDropped = false;
                }
            }
            
            if (gameState.powerUpActive) {
                gameState.powerUpTimer--;
                
                if (gameState.powerUpTimer <= 0) {
                    gameState.powerUpActive = false;
                    gameState.powerUpType = null;
                }
            }
            
            if (gameState.speedUpNotification) {
                gameState.speedUpNotificationTimer--;
                if (gameState.speedUpNotificationTimer <= 0) {
                    gameState.speedUpNotification = false;
                }
            }
            
            let currentSpeed = gameState.gameSpeed;
            
            gameState.camera.x += currentSpeed;
            gameState.distance = Math.floor(gameState.camera.x / 10);
            
            if (gameState.input.left) {
                player.velX = Math.max(player.velX - 1.2, -MOVE_SPEED);
                player.facing = 'left';
            } else if (gameState.input.right) {
                player.velX = Math.min(player.velX + 1.2, MOVE_SPEED);
                player.facing = 'right';
            } else {
                player.velX *= 0.85;
            }
            
            let jumpForce = JUMP_FORCE;
            if (gameState.powerUpType === 'lemon_can') {
                jumpForce *= 1.3;
            }
            
            if (gameState.input.jump && !gameState.input.jumpPressed && player.onGround) {
                player.velY = jumpForce;
                player.onGround = false;
                gameState.input.jumpPressed = true;
                soundManager.playJump();
            }
            
            if (!gameState.input.jump) {
                gameState.input.jumpPressed = false;
            }
            
            let currentGravity = GRAVITY;
            if (gameState.isRespawning) {
                currentGravity = GRAVITY / 5;
            }
            
            player.velY += currentGravity;
            if (player.velY > 15) player.velY = 15;
            
            player.x += player.velX;
            player.y += player.velY;
            
            if (player.x < gameState.camera.x + 25) {
                player.x = gameState.camera.x + 25;
            }
            if (player.x + player.width > gameState.camera.x + GAME_WIDTH - 25) {
                player.x = gameState.camera.x + GAME_WIDTH - 25 - player.width;
            }
            
            player.onGround = false;
            
            for (let t of terrain) {
                if (t.type !== 'hole' && checkCollision(player, t)) {
                    const playerBottom = player.y + player.height;
                    const playerRight = player.x + player.width;
                    const terrainTop = t.y;
                    const terrainRight = t.x + t.width;
                    
                    if (player.velY > 0 && playerBottom - player.velY <= terrainTop) {
                        player.y = t.y - player.height;
                        player.velY = 0;
                        player.onGround = true;
                        
                        if (gameState.isRespawning) {
                            gameState.isRespawning = false;
                        }
                    }
                    else if (player.velX > 0 && playerRight - player.velX <= t.x) {
                        player.x = t.x - player.width;
                        player.velX = 0;
                    } else if (player.velX < 0 && player.x - player.velX >= terrainRight) {
                        player.x = terrainRight;
                        player.velX = 0;
                    }
                    else if (player.velY < 0 && player.y - player.velY >= t.y + t.height) {
                        player.y = t.y + t.height;
                        player.velY = 0;
                    }
                }
            }
            
            for (let platform of platforms) {
                if (checkCollision(player, platform)) {
                    if (gameState.input.down && gameState.downSwipeActive && player.y < platform.y) {
                        gameState.input.down = false;
                        gameState.downSwipeActive = false;
                        gameState.downSwipeTimer = 0;
                        gameState.recentlyDropped = true;
                        gameState.dropFromY = player.y;
                        continue;
                    }
                    
                    if (gameState.recentlyDropped) {
                        continue;
                    }
                    
                    if (player.velY > 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velY = 0;
                        player.onGround = true;
                        
                        if (gameState.isRespawning) {
                            gameState.isRespawning = false;
                        }
                    }
                }
            }
            
            if (player.y > GAME_HEIGHT + 100) {
                takeDamage();
            }
        }
        
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                enemy.x += enemy.velX - gameState.gameSpeed;
                
                if (checkCollision(player, enemy)) {
                    if (gameState.powerUpType === 'shield' || gameState.isInvincible) {
                        enemies.splice(i, 1);
                        gameState.score += 200;
                        gameState.enemyKills++;
                        soundManager.playKill();
                        continue;
                    }
                    
                    const playerBottom = player.y + player.height;
                    const enemyTop = enemy.y;
                    const playerCenterY = player.y + player.height / 2;
                    const enemyCenterY = enemy.y + enemy.height / 2;
                    
                    if (playerCenterY < enemyCenterY && 
                        playerBottom <= enemyTop + enemy.height * 0.4) {
                        enemies.splice(i, 1);
                        player.velY = JUMP_FORCE / 2;
                        gameState.score += 200;
                        gameState.enemyKills++;
                        soundManager.playKill();
                    } else {
                        takeDamage();
                    }
                }
            }
            
            for (let i = flyingEnemies.length - 1; i >= 0; i--) {
                let enemy = flyingEnemies[i];
                enemy.x += enemy.velX - gameState.gameSpeed;
                
                if (checkCollision(player, enemy)) {
                    if (gameState.powerUpType === 'shield' || gameState.isInvincible) {
                        flyingEnemies.splice(i, 1);
                        gameState.score += 300;
                        gameState.enemyKills++;
                        continue;
                    }
                    
                    const playerBottom = player.y + player.height;
                    const enemyTop = enemy.y;
                    const playerCenterY = player.y + player.height / 2;
                    const enemyCenterY = enemy.y + enemy.height / 2;
                    
                    if (playerCenterY < enemyCenterY && 
                        playerBottom <= enemyTop + enemy.height * 0.5) {
                        flyingEnemies.splice(i, 1);
                        player.velY = JUMP_FORCE / 2;
                        gameState.score += 300;
                        gameState.enemyKills++;
                        soundManager.playKill();
                    } else {
                        flyingEnemies.splice(i, 1);
                        takeDamage();
                    }
                }
            }
        }
        
        function takeDamage() {
            if (gameState.isInvincible) return;
            
            gameState.lives--;
            soundManager.playDamage();
            gameState.isInvincible = true;
            gameState.invincibleTimer = INVINCIBLE_TIME;
            resetPlayerPosition();
            
            if (gameState.lives <= 0) {
                gameOver();
            }
        }
        
        function updateCoins() {
            for (let coin of coins) {
                if (!coin.collected && checkCollision(player, coin)) {
                    coin.collected = true;
                    gameState.score += 100;
                    soundManager.playCoin();
                }
            }
        }
        
        function updatePowerUps() {
            for (let powerUp of powerUps) {
                if (!powerUp.collected && checkCollision(player, powerUp)) {
                    powerUp.collected = true;
                    gameState.score += 500;
                    soundManager.playItem();
                    
                    if (powerUp.type === 'heart') {
                        if (gameState.lives < 9) {
                            gameState.lives++;
                        } else {
                            gameState.score += 1000;
                        }
                    } else {
                        gameState.powerUpActive = true;
                        gameState.powerUpType = powerUp.type;
                        gameState.powerUpTimer = 300;
                    }
                }
            }
        }
        
        function resetPlayerPosition() {
            const safeX = gameState.camera.x + 150;
            
            let foundSafeGround = false;
            let safeGroundX = safeX;
            
            for (let checkX = safeX; checkX < safeX + 600; checkX += 50) {
                let isSafe = false;
                for (let t of terrain) {
                    if (t.type !== 'hole' && 
                        checkX >= t.x && 
                        checkX <= t.x + t.width) {
                        isSafe = true;
                        foundSafeGround = true;
                        safeGroundX = checkX;
                        break;
                    }
                }
                if (isSafe) break;
            }
            
            player.x = foundSafeGround ? safeGroundX : safeX;
            player.y = -50;
            player.velX = 0;
            player.velY = 0;
            
            gameState.isRespawning = true;
            
            gameState.camera.x = Math.max(100, gameState.camera.x - 200);
        }
        
        async function gameOver() {
            log('gameOverÈñ¢Êï∞ÈñãÂßã');
            gameState.gameStarted = false;
            gameState.gamePaused = true;

            if (soundManager) {
                soundManager.playBGM('gameover');
            }
            
            finalGameStats = {
                score: gameState.score,
                distance: gameState.distance,
                enemyKills: gameState.enemyKills,
                speedLevel: gameState.speedLevel
            };
            
            try {
                const isHighScore = await checkHighScore(finalGameStats);
                
                setTimeout(() => {
                    if (isHighScore) {
                        showNameInput();
                    } else {
                        alert(`„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº\n` +
                              `„Åù„Çå„ÅØ„Å°„Çá„Å£„Å®‰∏ñÈñì„ÅØË®±„Åó„Å¶„Åè„Çå„Åæ„Åõ„Çì„Çà„Äúüê§\n` +
                              `Âà∞ÈÅîË∑ùÈõ¢: ${finalGameStats.distance}m\n` +
                              `Áï•Â•™ÈáëÈ°ç: ${finalGameStats.score}ÂÜÜ\n` +
                              `ÊïµÊíÉÁ†¥Êï∞: ${finalGameStats.enemyKills}‰Ωì\n` +
                              `Âà∞ÈÅî„É¨„Éô„É´: ${finalGameStats.speedLevel}`);
                        resetGame();
                    }
                }, 500);
                
            } catch (error) {
                console.error('„Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂá¶ÁêÜ„Ç®„É©„Éº:', error);
                setTimeout(() => {
                    alert(`„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº\n` +
                          `„Åù„Çå„ÅØ„Å°„Çá„Å£„Å®‰∏ñÈñì„ÅØË®±„Åó„Å¶„Åè„Çå„Åæ„Åõ„Çì„Çà„Äúüê§\n` +
                          `Âà∞ÈÅîË∑ùÈõ¢: ${finalGameStats.distance}m\n` +
                          `ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${finalGameStats.score}ÁÇπ\n` +
                          `ÊïµÊíÉÁ†¥Êï∞: ${finalGameStats.enemyKills}‰Ωì\n` +
                          `Âà∞ÈÅî„É¨„Éô„É´: ${finalGameStats.speedLevel}`);
                    resetGame();
                }, 500);
            }
        }
        
        function pauseGame() {
            if (!gameState.gameStarted) return;
            gameState.gamePaused = !gameState.gamePaused;
            
            if (gameState.gamePaused) {
                document.getElementById('pauseScreen').classList.remove('hidden');
                document.getElementById('pauseButton').textContent = '‚ñ∂Ô∏è';
            } else {
                document.getElementById('pauseScreen').classList.add('hidden');
                document.getElementById('pauseButton').textContent = '‚è∏Ô∏è';
            }
        }
        
        function requestFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }
        
        function startGame() {
            log('„Ç≤„Éº„É†ÈñãÂßã');
            
            if (soundManager && soundManager.playBGM) {
                try {
                    soundManager.playBGM('stage');
                } catch (error) {
                    console.error('BGMÂÜçÁîü„Ç®„É©„Éº:', error);
                }
            }
            
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                requestFullscreen();
            }
            
            gameState.gameStarted = true;
            gameState.gamePaused = false;
            
            const startScreen = document.getElementById('startScreen');
            startScreen.classList.add('hidden');
            startScreen.style.display = 'none';
            
            document.getElementById('pauseScreen').classList.add('hidden');
            
            document.getElementById('titleButtons').style.display = 'none';
            document.getElementById('startMessage').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            
            window.scrollTo(0, 1);
        }
        
        function resetGame() {
            gameState.score = 0;
            gameState.lives = 3;
            gameState.gameStarted = false;
            gameState.gamePaused = false;
            gameState.enemySpawnTimer = 0;
            gameState.platformSpawnTimer = 0;
            gameState.coinSpawnTimer = 0;
            gameState.flyingEnemySpawnTimer = 0;
            gameState.powerUpSpawnTimer = 0;
            gameState.distance = 0;
            gameState.gameSpeed = BASE_AUTO_SCROLL_SPEED;
            gameState.camera.x = 0;
            gameState.camera.y = 0;
            gameState.powerUpActive = false;
            gameState.powerUpTimer = 0;
            gameState.powerUpType = null;
            gameState.isInvincible = false;
            gameState.invincibleTimer = 0;
            gameState.speedLevel = 1;
            gameState.lastSpeedUpDistance = 0;
            gameState.speedUpNotification = false;
            gameState.speedUpNotificationTimer = 0;
            gameState.downSwipeTimer = 0;
            gameState.downSwipeActive = false;
            gameState.isRespawning = false;
            gameState.enemyKills = 0;
            
            player.x = 150;
            player.y = 350;
            player.velX = 0;
            player.velY = 0;
            player.onGround = false;
            player.facing = 'right';
            
            coins = [];
            enemies = [];
            platforms = [];
            flyingEnemies = [];
            powerUps = [];
            
            initTerrain();
            
            const startScreen = document.getElementById('startScreen');
            startScreen.classList.remove('hidden');
            startScreen.style.display = 'block';
            
            document.getElementById('pauseScreen').classList.add('hidden');
            document.getElementById('pauseButton').textContent = '‚è∏Ô∏è';
            
            document.getElementById('ui').style.display = 'none';
            document.getElementById('titleButtons').style.display = 'flex';
            document.getElementById('startMessage').style.display = 'block';
            
            if (soundManager) {
                soundManager.playBGM('title');
            }
        }
        
        function render() {
            const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            gradient.addColorStop(0, '#87ceeb');
            gradient.addColorStop(0.25, '#98d8e8');
            gradient.addColorStop(0.5, '#ffb6c1');
            gradient.addColorStop(0.75, '#ffc0cb');
            gradient.addColorStop(1, '#ff69b4');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 15; i++) {
                const x = (i * 220 - gameState.camera.x * 0.3 + gameState.time * 0.2) % (GAME_WIDTH + 180);
                const y = 40 + Math.sin(i * 0.7 + gameState.time * 0.01) * 40;
                
                ctx.fillRect(x, y, 120, 35);
                ctx.fillRect(x + 25, y - 12, 70, 60);
                ctx.fillRect(x + 15, y + 8, 90, 25);
                ctx.fillRect(x + 50, y - 18, 35, 45);
            }
            
            ctx.save();
            ctx.translate(-gameState.camera.x, 0);
            
            for (let t of terrain) {
                if (t.x + t.width > gameState.camera.x - 100 && 
                    t.x < gameState.camera.x + GAME_WIDTH + 100) {
                    drawTerrain(t);
                }
            }
            
            for (let platform of platforms) {
                if (platform.x + platform.width > gameState.camera.x - 100 && 
                    platform.x < gameState.camera.x + GAME_WIDTH + 100) {
                    drawPlatform(platform);
                }
            }
            
            const time = Date.now() / 50;
            for (let coin of coins) {
                if (!coin.collected && coin.x > gameState.camera.x - 100 && 
                    coin.x < gameState.camera.x + GAME_WIDTH + 100) {
                    drawCoin(coin, time);
                }
            }
            
            for (let enemy of enemies) {
                if (enemy.x > gameState.camera.x - 100 && 
                    enemy.x < gameState.camera.x + GAME_WIDTH + 100 && enemy.x > -100) {
                    drawEnemy(enemy);
                }
            }
            
            for (let enemy of flyingEnemies) {
                if (enemy.x > gameState.camera.x - 100 && 
                    enemy.x < gameState.camera.x + GAME_WIDTH + 100 && enemy.x > -100) {
                    drawFlyingEnemy(enemy);
                }
            }
            
            for (let powerUp of powerUps) {
                if (!powerUp.collected && powerUp.x > gameState.camera.x - 100 && 
                    powerUp.x < gameState.camera.x + GAME_WIDTH + 100) {
                    drawPowerUp(powerUp);
                }
            }
            
            if (gameState.gameStarted) {
                drawPlayer(player.x, player.y);
            }
            
            ctx.restore();
            
            if (gameState.powerUpActive) {
                const remainingTime = Math.ceil(gameState.powerUpTimer / 60);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(GAME_WIDTH - 200, 80, 180, 60);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                
                let powerUpName = '';
                switch(gameState.powerUpType) {
                    case 'lemon_can':
                        powerUpName = 'üçã „Ç∏„É£„É≥„ÉóÂº∑Âåñ';
                        break;
                    case 'shield':
                        powerUpName = 'üõ°Ô∏è ÁÑ°ÊïµÁä∂ÊÖã';
                        break;
                }
                
                ctx.fillText(powerUpName, GAME_WIDTH - 190, 100);
                ctx.fillText(`ÊÆã„ÇäÊôÇÈñì: ${remainingTime}Áßí`, GAME_WIDTH - 190, 120);
            }
            
            if (gameState.isInvincible) {
                const remainingTime = Math.ceil(gameState.invincibleTimer / 60);
                ctx.fillStyle = 'rgba(255, 215, 0, 0.7)';
                ctx.fillRect(GAME_WIDTH / 2 - 100, 20, 200, 40);
                
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚≠ê ÁÑ°ÊïµÊôÇÈñì: ' + remainingTime + 'Áßí', GAME_WIDTH / 2, 45);
            }
            
            if (gameState.speedUpNotification) {
                const alpha = Math.min(1.0, gameState.speedUpNotificationTimer / 30);
                ctx.fillStyle = `rgba(255, 69, 180, ${alpha * 0.8})`;
                ctx.fillRect(GAME_WIDTH / 2 - 140, 70, 280, 50);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                const speedPercent = Math.min(500, 100 + (gameState.speedLevel - 1) * 20);
                ctx.fillText(`üöÄ SPEED UP! „É¨„Éô„É´ ${gameState.speedLevel} (${speedPercent}%)`, GAME_WIDTH / 2, 100);
            }
            
            if (gameState.gamePaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚è∏Ô∏è „Éù„Éº„Ç∫‰∏≠', GAME_WIDTH/2, GAME_HEIGHT/2);
            }
            
            gameState.time++;
        }
        
        function isOnPlatform() {
            if (!player.onGround) {
                return false;
            }
            
            const playerBottom = player.y + player.height;
            const playerLeft = player.x;
            const playerRight = player.x + player.width;
            
            for (let platform of platforms) {
                const horizontalOverlap = playerRight > platform.x && playerLeft < platform.x + platform.width;
                const verticalDistance = Math.abs(playerBottom - platform.y);
                
                if (horizontalOverlap && verticalDistance <= 5) {
                    return true;
                }
            }
            
            return false;
        }

        const leftArea = document.getElementById('leftArea');
        const rightArea = document.getElementById('rightArea');
        
        let leftTouchStartY = 0;
        let leftTouchStartTime = 0;
        let leftIsSwipeDetected = false;
        
        leftArea.addEventListener('touchstart', (e) => {
            if (!gameState.gameStarted || gameState.gamePaused) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = leftArea.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            
            if (touchX < rect.width * 0.3284) {
                gameState.input.left = true;
                gameState.input.right = false;
                leftArea.classList.add('left-active');
                leftArea.classList.remove('right-active');
            } else {
                gameState.input.right = true;
                gameState.input.left = false;
                leftArea.classList.add('right-active');
                leftArea.classList.remove('left-active');
            }
            
            leftTouchStartY = touch.clientY;
            leftTouchStartTime = Date.now();
            leftIsSwipeDetected = false;
        });
        
        leftArea.addEventListener('touchmove', (e) => {
            if (!gameState.gameStarted || gameState.gamePaused) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = leftArea.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            
            const currentY = touch.clientY;
            const deltaY = currentY - leftTouchStartY;
            const deltaTime = Date.now() - leftTouchStartTime;
            
            if (deltaY > 15 && deltaTime < 500 && !leftIsSwipeDetected) {
                if (isOnPlatform()) {
                    leftIsSwipeDetected = true;
                    gameState.input.down = true;
                    gameState.downSwipeActive = true;
                    gameState.downSwipeTimer = 30;
                    
                    gameState.input.left = false;
                    gameState.input.right = false;
                    leftArea.classList.remove('left-active', 'right-active');
                }
                return;
            }
            
            if (!leftIsSwipeDetected) {
                if (touchX < rect.width * 0.3284) {
                    gameState.input.left = true;
                    gameState.input.right = false;
                    leftArea.classList.add('left-active');
                    leftArea.classList.remove('right-active');
                } else {
                    gameState.input.right = true;
                    gameState.input.left = false;
                    leftArea.classList.add('right-active');
                    leftArea.classList.remove('left-active');
                }
            }
        });
        
        leftArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            leftArea.classList.remove('left-active', 'right-active');
            gameState.input.left = false;
            gameState.input.right = false;
        });
        
        rightArea.addEventListener('touchstart', (e) => {
            if (!gameState.gameStarted || gameState.gamePaused) return;
            e.preventDefault();
            rightArea.classList.add('active');
            gameState.input.jump = true;
        });
        
        rightArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            rightArea.classList.remove('active');
            gameState.input.jump = false;
        });
        
        document.getElementById('pauseScreen').addEventListener('click', (e) => {
            if (e.target === document.getElementById('pauseScreen')) {
                pauseGame();
            }
        });
        
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                pauseGame();
                return;
            }
            
            if (gameState.gamePaused && e.key === ' ') {
                e.preventDefault();
                pauseGame();
                return;
            }
            
            if (!gameState.gameStarted || gameState.gamePaused) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    gameState.input.left = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    gameState.input.right = true;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (isOnPlatform()) {
                        gameState.input.down = true;
                        gameState.downSwipeActive = true;
                        gameState.downSwipeTimer = 30;
                    }
                    break;
                case ' ':
                case 'ArrowUp':
                case 'w':
                case 'W':
                    gameState.input.jump = true;
                    e.preventDefault();
                    break;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    gameState.input.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    gameState.input.right = false;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    gameState.input.down = false;
                    gameState.downSwipeActive = false;
                    gameState.downSwipeTimer = 0;
                    break;
                case ' ':
                case 'ArrowUp':
                case 'w':
                case 'W':
                    gameState.input.jump = false;
                    break;
            }
        });
        
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            
            if (window.innerWidth > window.innerHeight) {
                const padding = 20;
                const availableWidth = window.innerWidth - (padding * 2);
                const availableHeight = window.innerHeight - (padding * 2);
                
                const gameAspectRatio = GAME_WIDTH / GAME_HEIGHT;
                const screenAspectRatio = availableWidth / availableHeight;
                
                let scale = 1;
                if (screenAspectRatio > gameAspectRatio) {
                    scale = availableHeight / GAME_HEIGHT;
                } else {
                    scale = availableWidth / GAME_WIDTH;
                }
                
                scale *= 0.9;
                
                const scaledWidth = GAME_WIDTH * scale;
                const scaledHeight = GAME_HEIGHT * scale;
                
                canvas.style.width = scaledWidth + 'px';
                canvas.style.height = scaledHeight + 'px';
                canvas.style.position = 'absolute';
                canvas.style.left = ((window.innerWidth - scaledWidth) / 2) + 'px';
                canvas.style.top = ((window.innerHeight - scaledHeight) / 2) + 'px';
                
                const gameContainer = document.getElementById('gameContainer');
                gameContainer.style.width = window.innerWidth + 'px';
                gameContainer.style.height = window.innerHeight + 'px';
            }
            
            if (window.innerHeight < window.screen.height) {
                window.scrollTo(0, 1);
            }
        }
        
        function initialize() {
            try {
                const titleImages = [
                    'https://img.fpack.jp/shop/nyanpon/images/173986677576251900.jpg',
                    'https://pbs.twimg.com/media/GjvkMpDbgAApxmV?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GciMiL2aIAAXf8F?format=jpg&name=large',
                    'https://pbs.twimg.com/media/Ga3_BR3a4AAgc_m?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GX6886xaUAAC__z?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GXCixTOaIAAPKQn?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GW4jaRia8AgIaKo?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GVqdm_QWAAEB1_M?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GTXMJxvbUAA9pJV?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GS5jdSCb0AIb1yg?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GOMVeyGbEAAlHvU?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GNoRs-wbAAACsqf?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GNjCkrfbsAAiLcV?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GNTT9GzaMAAhEz_?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GMV3GZmaEAABA93?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GLvDPBCaIAAJLhr?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GLiBKmabIAA2GTd?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GKsH8HwaEAA0jgj?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GKC_I85asAAu3J4?format=jpg&name=small',
                    'https://pbs.twimg.com/media/GDkmuTwaoAAvpvo?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GCr1j_wbMAAE043?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GCeLMl6bgAA8Uny?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GBUVkxhbUAAb_tP?format=jpg&name=large',
                    'https://pbs.twimg.com/media/F_eZbKpbEAA7T7z?format=jpg&name=large',
                    'https://pbs.twimg.com/media/F9vkq_yaEAA6TrA?format=jpg&name=large',
                    'https://pbs.twimg.com/media/F8FVHdwbYAAL-a1?format=jpg&name=large',
                    'https://pbs.twimg.com/media/F8FVHdxaAAA78Zg?format=jpg&name=medium',
                    'https://pbs.twimg.com/media/F2nRkPCbcAAWcEg?format=jpg&name=large',
                    'https://pbs.twimg.com/media/Gq0121oXEAAaCfx?format=jpg&name=large',
                    'https://github.com/RhynAkesora/piyo/blob/main/IMG_1509.jpeg?raw=true',
                    'https://github.com/RhynAkesora/piyo/blob/main/IMG_1538.jpeg?raw=true',
                    'https://pbs.twimg.com/media/GsxRrUwagAACft6?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GsXHt-GaoAAxmfi?format=jpg&name=large',
                    'https://pbs.twimg.com/media/Gr9h-Q5WkAAsg3W?format=jpg&name=large',
                    'https://pbs.twimg.com/media/GrKKOACWIAAfJNN?format=jpg&name=large',
                ];
                
                const randomIndex = Math.floor(Math.random() * titleImages.length);
                const selectedImage = titleImages[randomIndex];
                
                const titleImageElement = document.getElementById('titleImage');
                if (titleImageElement) {
                    titleImageElement.onerror = function() {
                        console.error('ÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó:', selectedImage);
                        titleImageElement.src = 'https://img.fpack.jp/shop/nyanpon/images/173986677576251900.jpg';
                    };
                    
                    titleImageElement.src = selectedImage;
                    titleImageElement.style.display = 'block';
                }
                
                initTerrain();
                resizeCanvas();
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('ÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
            }

            showSplashScreen();
        }
        
        function checkOrientation() {
            if (window.orientation !== undefined) {
                if (window.orientation === 0 || window.orientation === 180) {
                    log('Á∏¶Âêë„Åç„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü');
                }
            }
            
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(function(error) {
                    log('ÁîªÈù¢„ÅÆÂêë„Åç„ÅÆ„É≠„ÉÉ„ÇØ„Å´Â§±Êïó:', error);
                });
            }
        }
        
        function showStartScreen() {
            log('„Çø„Ç§„Éà„É´ÁîªÈù¢Ë°®Á§∫');
            
            resetGame();
            
            const startScreen = document.getElementById('startScreen');
            if (startScreen) {
                startScreen.classList.remove('hidden');
            }
            
            document.getElementById('pauseScreen').classList.add('hidden');
            document.getElementById('rankingScreen').classList.add('hidden');
            document.getElementById('rankingScreen').style.display = 'none';
            const nameInputScreen = document.getElementById('nameInputScreen');
            if (nameInputScreen) {
                nameInputScreen.classList.add('hidden');
                nameInputScreen.style.display = 'none';
            }
            
            startApp();
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const canvasCheck = document.getElementById('gameCanvas');
            const titleImageCheck = document.getElementById('titleImage');
            
            log('CanvasË¶ÅÁ¥†:', canvasCheck ? 'Â≠òÂú®„Åô„Çã' : 'Â≠òÂú®„Åó„Å™„ÅÑ');
            log('„Çø„Ç§„Éà„É´ÁîªÂÉèË¶ÅÁ¥†:', titleImageCheck ? 'Â≠òÂú®„Åô„Çã' : 'Â≠òÂú®„Åó„Å™„ÅÑ');
            
            setTimeout(function() {
                try {
                    initialize();
                    checkOrientation();
                    
                    window.addEventListener('orientationchange', function() {
                        setTimeout(() => {
                            checkOrientation();
                            resizeCanvas();
                        }, 100);
                    });
                    
                    setTimeout(function() {
                        window.scrollTo(0, 1);
                    }, 100);
                    
                } catch (error) {
                    console.error('ÂàùÊúüÂåñ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü:', error);
                    alert('„Ç≤„Éº„É†„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü\n„Ç®„É©„Éº: ' + error.message);
                }
            }, 100);
        });
        
        window.addEventListener('resize', () => {
            resizeCanvas();
            checkOrientation();
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                resizeCanvas();
                checkOrientation();
            }, 100);
        });
        
        document.addEventListener('touchmove', (e) => {
            if (e.target.tagName !== 'INPUT') {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.gameStarted && !gameState.gamePaused) {
                pauseGame();
            }
        });
        
        window.addEventListener('blur', () => {
            if (gameState.gameStarted && !gameState.gamePaused) {
                pauseGame();
            }
        });
    </script>
</body>
</html>
